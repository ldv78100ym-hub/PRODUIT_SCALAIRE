<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cours et Exercices Dynamiques : Le Produit Scalaire</title>
    <style>
        /* --- CSS EXISTANT (Cours) --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px auto;
            max-width: 950px;
            padding: 30px;
            border: 1px solid #ccc;
            line-height: 1.6;
            color: #333;
            background-color: #fcfcfc;
        }

        /* Bouton Retour Ressources */
        #back-btn {
            display: inline-block;
            text-decoration: none;
            background-color: #6c757d; /* Gris secondaire */
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 0.95em;
            font-weight: 600;
            transition: background 0.3s;
            margin-bottom: 20px;
        }
        #back-btn:hover { background-color: #5a6268; }

        .header {
            display: flex;
            justify-content: space-between;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
            margin-bottom: 30px;
            font-size: 1.1em;
            color: #0056b3;
            font-weight: bold;
        }

        .main-title {
            text-align: center;
            font-size: 2.5em;
            color: #0056b3;
            margin-top: 0;
            padding-bottom: 15px;
            border-bottom: 3px solid #0056b3;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        h2 { font-size: 1.6em; color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 8px; margin-top: 40px; }
        h3 { font-size: 1.3em; color: #555; margin-top: 20px; }

        .math-display {
            display: block;
            overflow-x: auto;
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px dashed #ced4da;
            border-radius: 8px;
            font-size: 1.2em;
        }

        .exercice-bloc {
            background-color: #fff;
            border-left: 6px solid #007bff;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border-radius: 0 5px 5px 0;
        }
        .niveau-titre { font-size: 1.1em; font-weight: bold; color: #28a745; margin-top: 0; }
        .solution-bloc { 
            background-color: #e8f5e9; padding: 15px; border: 1px solid #c8e6c9; 
            border-radius: 5px; margin-top: 15px; display: none; 
        }
        .document-analyse {
            background-color: #fdfdfe; font-style: italic; color: #555;
            border: 1px solid #e0e0e0; border-left: 4px solid #6c757d;
            padding: 15px; margin: 15px 0;
        }

        .btn-action {
            padding: 10px 20px; margin-top: 10px; cursor: pointer; border: none;
            border-radius: 4px; font-weight: 600; font-size: 0.95em; transition: background 0.3s;
        }
        .btn-relance { background-color: #007bff; color: white; margin-bottom: 20px; width: 100%; font-size: 1.1em; }
        .btn-relance:hover { background-color: #0056b3; }
        .btn-solution { background-color: #ffc107; color: #333; margin-right: 10px; }
        .btn-solution:hover { background-color: #e0a800; }
        .btn-reset-ex { background-color: #17a2b8; color: white; margin-right: 10px; }
        .btn-reset-ex:hover { background-color: #138496; }

        .data-table { width: 100%; border-collapse: collapse; margin: 15px 0; text-align: center; }
        .data-table th, .data-table td { border: 1px solid #dee2e6; padding: 10px; }
        .data-table th { background-color: #e9ecef; color: #495057; }

        .canvas-container { text-align: center; margin: 20px auto; }
        canvas { background-color: #fff; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .remarque { margin-top: 15px; padding: 10px 15px; border-left: 4px solid #ffc107; background-color: #fffbf2; font-style: italic; color: #666; }

        /* --- NOUVEAU CSS : MODALE DROITS D'AUTEUR --- */
        .footer-actions {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
        }
        
        #copyright-btn {
            background-color: #ffc107; /* Couleur jaune copyright */
            color: #343a40;
            margin: 0 auto;
        }

        .modal {
            display: none; 
            position: fixed; z-index: 1000; 
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; 
            background-color: rgba(0,0,0,0.6); 
            animation: fadeIn 0.3s;
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; 
            padding: 30px;
            border: 1px solid #888;
            width: 80%; 
            max-width: 700px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-family: 'Segoe UI', sans-serif;
            text-align: left;
        }
        
        .close-btn {
            color: #aaa; float: right; font-size: 28px; font-weight: bold;
            transition: color 0.2s;
        }
        .close-btn:hover, .close-btn:focus {
            color: #000; text-decoration: none; cursor: pointer;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content { margin: 15% auto; width: 90%; padding: 20px; }
        }
        @media print {
            .footer-actions, .btn-action, .modal, #back-btn { display: none !important; }
        }
	/* --- 1. RESPONSIVE (MOBILE) --- */
        @media (max-width: 768px) {
            body { padding: 10px; margin: 0; }
            .header { flex-direction: column; text-align: center; gap: 10px; }
            .main-title { font-size: 1.8em; }
            .math-display { font-size: 1em; padding: 10px; overflow-x: auto; }
            .data-table { display: block; overflow-x: auto; white-space: nowrap; }
            canvas { max-width: 100%; height: auto; }
            /* Panneau de score plus petit sur mobile */
            #score-panel { top: auto; bottom: 10px; right: 10px; font-size: 0.9em; padding: 8px; }
        }

        /* --- 2. IMPRESSION (PDF PROPRE) --- */
        @media print {
            body { background-color: white; border: none; width: 100%; max-width: 100%; padding: 0; margin: 0; }
            /* Cacher les √©l√©ments interactifs */
            .btn-action, #back-btn, #score-panel, .footer-actions, .btn-reset-ex, .btn-solution { display: none !important; }
            /* S'assurer que les solutions sont visibles si l'utilisateur veut imprimer le corrig√© */
            .solution-bloc { display: block !important; border: 1px solid #ccc; break-inside: avoid; }
            .exercice-bloc { break-inside: avoid; border: 1px solid #333; box-shadow: none; margin-bottom: 20px; }
            /* Couleurs pour l'impression */
            .niveau-titre { color: #000 !important; }
            a { text-decoration: none; color: black; }
        }

        /* --- 3. WIDGET DE SCORE --- */
        #score-panel {
            position: fixed; top: 20px; right: 20px;
            background-color: #fff; border: 2px solid #007bff;
            padding: 15px; border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 999; font-family: 'Segoe UI', sans-serif;
            display: flex; flex-direction: column; align-items: center;
        }
        .score-row { display: flex; gap: 15px; font-size: 1.2em; font-weight: bold; }
        .score-success { color: #28a745; }
        .score-fail { color: #dc3545; }
        .score-title { font-size: 0.8em; color: #666; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; }
        
        /* Boutons d'auto-√©valuation dans les solutions */
        .eval-buttons { margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 10px; text-align: center; }
        .btn-eval { padding: 5px 10px; font-size: 0.9em; border: 1px solid #ccc; background: #fff; cursor: pointer; border-radius: 4px; margin: 0 5px; transition: all 0.2s; }
        .btn-eval:hover { transform: scale(1.05); }
        .btn-eval.success:hover { background-color: #d4edda; border-color: #28a745; }
        .btn-eval.fail:hover { background-color: #f8d7da; border-color: #dc3545; }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']], 
                displayMath: [['\\[', '\\]']] 
            }
        };
    </script>
</head>
<body>

    <a href="https://ldv78100ym-hub.github.io/HOME/" id="back-btn">‚Ü© Retour Ressources</a>

    <div class="header">
        <span>Cours : Produit Scalaire</span>
        <span>1<sup>re</sup> STI2D / STL</span>
    </div>

    <h1 class="main-title">Le Produit Scalaire : Un Outil Puissant</h1>
    
    <p>Le produit scalaire est une op√©ration math√©matique qui prend deux vecteurs et donne un <strong>nombre</strong> (un scalaire). Ce nombre est essentiel car il lie la <strong>longueur</strong> des vecteurs et l'<strong>angle</strong> qu'ils forment.</p>

    <h2>D√©finition G√©om√©trique : L'Essence de l'Angle</h2>
    
    
    <div class="canvas-container">
        <canvas id="canvas_cours_geo" width="400" height="200"></canvas>
    </div>

    <h3>Formule du Produit Scalaire</h3>
    <p>Si \(\vec{u}\) et \(\vec{v}\) sont non nuls, le produit scalaire est d√©fini par :</p>
    <div class="math-display">
        \[\vec{u} \cdot \vec{v} = \left\Vert \vec{u} \right\Vert \times \left\Vert \vec{v} \right\Vert \times \cos(\theta)\]
    </div>
    <p>O√π :</p>
    <ul>
        <li>\(\left\Vert \vec{u} \right\Vert\) et \(\left\Vert \vec{v} \right\Vert\) sont les <strong>normes</strong> (longueurs) des vecteurs.</li>
        <li>\(\theta\) est l'<strong>angle orient√©</strong> entre \(\vec{u}\) et \(\vec{v}\).</li>
    </ul>

    <h3>Caract√©risation de l'Orthogonalit√©</h3>
    <p>Le terme \(\cos(\theta)\) permet de d√©terminer l'orientation relative des vecteurs. Le cas le plus important est celui de l'orthogonalit√©.</p>
    <div class="math-display">
        \[\vec{u} \perp \vec{v} \iff \vec{u} \cdot \vec{v} = 0\]
    </div>
    <div class="remarque">
        <p>Si les vecteurs sont perpendiculaires, \(\theta = 90^\circ~~\left(\text{respectivement : }~\theta=\dfrac{\pi}{2}\right)\),</p>
	<p>alors \(\cos(90^\circ) = 0~~\left(\text{respectivement : }~\cos\left(\dfrac{\pi}{2}\right)=0\right)\)</p>
    </div>

    <h2>Projection Orthogonale : La Mesure de l'Effet Utile</h2>
    
    <p>Le produit scalaire peut √™tre interpr√©t√© comme le produit de la norme d'un vecteur par la mesure alg√©brique de la projection de l'autre.</p>
    
    
    <div class="canvas-container">
        <canvas id="canvas_cours_proj" width="400" height="200"></canvas>
    </div>

    <p>Soit \(\vec{u'}\) (ou \(\vec{AH}\)) la projection orthogonale de \(\vec{u}\) sur l'axe dirig√© par \(\vec{v}\). La formule devient :</p>
    <div class="math-display">
        \[\vec{u} \cdot \vec{v} = \overline{AH} \times ||\vec{v}||\]
    </div>
    <p>Cette m√©thode est particuli√®rement utile quand les longueurs projet√©es sont faciles √† lire sur une grille ou un sch√©ma, √©vitant le calcul explicite de l'angle \(\theta\).</p>

    <h2>D√©finition Analytique (Dans un Rep√®re Orthonorm√©)</h2>

    <p>Les situations de g√©om√©trie rep√©r√©e sont uniquement trait√©es dans un <strong>rep√®re orthonorm√©</strong> \((O; \vec{i}, \vec{j})\). Si les coordonn√©es des vecteurs sont :</p>
    <div class="math-display">
        \[\vec{u} \begin{pmatrix} x \\ y \end{pmatrix} \quad \text{et} \quad \vec{v} \begin{pmatrix} x' \\ y' \end{pmatrix}\]
    </div>
    <p>Le produit scalaire est donn√© par la formule :</p>
    <div class="math-display">
        \[\vec{u} \cdot \vec{v} = x x' + y y'\]
    </div>

    <h3>Norme d'un vecteur (Carr√© Scalaire)</h3>
    <p>La norme d'un vecteur est li√©e au produit scalaire du vecteur par lui-m√™me (carr√© scalaire) :</p>
    <div class="math-display">
        \[||\vec{u}|| = \sqrt{\vec{u} \cdot \vec{u}} = \sqrt{x^2 + y^2}\]
    </div>
    <h3>Formule de Polarisation (Lien avec les normes)</h3>
    <p>Cette formule permet de calculer le produit scalaire en utilisant uniquement les normes des vecteurs (somme et individuelles) :</p>
    <div class="math-display">
        \[\vec{u} \cdot \vec{v} = \dfrac{1}{2} \left( \left\Vert \vec{u} + \vec{v} \right\Vert^2 - \left\Vert \vec{u} \right\Vert^2 - \left\Vert \vec{v} \right\Vert^2 \right)\]
    </div>
    <h2>Propri√©t√©s Alg√©briques (Calcul Simplifi√©)</h2>
    <p>Le produit scalaire v√©rifie des propri√©t√©s semblables au calcul litt√©ral classique sur les r√©els :</p>
    <ul>
        <li><strong>Sym√©trie :</strong> \(\vec{u} \cdot \vec{v} = \vec{v} \cdot \vec{u}\)</li>
        <li><strong>Bilin√©arit√© :</strong> Pour tout r√©el \(k\) et tous vecteurs \(\vec{u}, \vec{v}, \vec{w}\) :
            <ul>
                <li>\(\vec{u} \cdot (\vec{v} + \vec{w}) = \vec{u} \cdot \vec{v} + \vec{u} \cdot \vec{w}\) (Distributivit√©)</li>
                <li>\((k\vec{u}) \cdot \vec{v} = k (\vec{u} \cdot \vec{v})\)</li>
            </ul>
        </li>
    </ul>
    <div class="remarque">
        En physique, la bilin√©arit√© justifie que le travail de la force r√©sultante est √©gal √† la somme des travaux de chaque force.
    </div>

    <h2>Lien Fondamental avec la Physique : Le Travail d'une Force</h2>
    
    
    <div class="canvas-container">
        <canvas id="canvas_cours_travail" width="500" height="200"></canvas>
    </div>

    <p>En physique, le produit scalaire sert √† calculer le <strong>travail</strong> \(W\) d'une force constante \(\vec{F}\) lors d'un d√©placement rectiligne \(\vec{AB}\) (not√© \(\vec{d}\)).</p>
    <div class="math-display">
        \[W = \vec{F} \cdot \vec{d} = ||\vec{F}|| \times ||\vec{d}|| \times \cos(\theta)\]
    </div>
    <ul>
        <li>Si la force est <strong>perpendiculaire</strong> au d√©placement, \(W = 0\) (Travail nul).</li>
        <li>Si \(\cos(\theta) > 0\), le travail est <strong>moteur</strong>.</li>
        <li>Si \(\cos(\theta) < 0\), le travail est <strong>r√©sistant</strong>.</li>
    </ul>
    
    <h2>Applications aux Triangles et Longueurs</h2>

    <h3>Th√©or√®me d'Al-Kashi (Loi des cosinus)</h3>
    <p>Ce th√©or√®me est une <strong>g√©n√©ralisation du Th√©or√®me de Pythagore</strong>. Dans un triangle \(ABC\) :</p>

    
    <div class="canvas-container">
        <canvas id="canvas_cours_alkashi" width="400" height="250"></canvas>
    </div>

    <div class="math-display">
        \[c^2 = a^2 + b^2 - 2ab \cos(\widehat{C})\]
    </div>

    <h3>√âgalit√© du Parall√©logramme</h3>
    <p>Si \(\vec{u}\) et \(\vec{v}\) forment un parall√©logramme, cette √©galit√© relie les carr√©s des longueurs des c√¥t√©s et des diagonales:</p>
    <div class="math-display">
        \[||\vec{u} + \vec{v}||^2 + ||\vec{u} - \vec{v}||^2 = 2 \\left( ||\vec{u}||^2 + ||\vec{v}||^2 \\right)\]
    </div>

    <hr>
    
    <h1 class="main-title" style="color:#28a745; border-bottom: 2px solid #28a745;">üöÄ Exercices Dynamiques</h1>
    
    <h2>1. D√©finition G√©om√©trique : L'Essence de l'Angle</h2>
    
    <div class="exercice-bloc">
        <h3 class="niveau-titre">Niveau 2 : Calcul avec angles en radians</h3>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> \(\left\Vert \vec{u}\right\Vert = \)<span id="u_norm_1_2"></span>, \(\left\Vert \vec{v} \right\Vert = \)<span id="v_norm_1_2"></span>.
            Angle \((\vec{u}, \vec{v}) = \)<span id="angle_val_1_2"></span>.
        </div>
        <p><strong>Question :</strong> Calculer la valeur exacte du produit scalaire \(\vec{u} \cdot \vec{v}\).</p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_1_2', generateEx1_2)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_1_2')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_1_2">
            <p><strong>Solution :</strong></p>
            <p>1. Analyse de l'angle : <span id="angle_analysis_1_2"></span></p>
            <p>2. Valeur du cosinus :</p>
            <div id="sol_cos_1_2" class="math-display"></div>
            <p>3. Calcul final :</p>
            <div id="sol_calc_1_2" class="math-display"></div>
        </div>
    </div>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">Niveau 3 : Orthogonalit√© conditionnelle</h3>
        <div class="document-analyse">
            <strong>Document :</strong> \(\left\Vert \vec{u} \right\Vert = \)<span id="u_norm_1"></span>. On cherche \(\vec{v}\) avec \(\left\Vert \vec{v} \right\Vert = \)<span id="v_norm_1"></span> tel que <span id="vec_w_eq"></span> soit orthogonal √† \(\vec{v}\).
        </div>
        <p><strong>Question :</strong> D√©terminer l'angle \(\theta\) (en degr√©s).</p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_1_3', generateEx1_3)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_1_3')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_1_3">
            <p><strong>Solution :</strong></p>
            <p>Condition d'orthogonalit√© : \(\vec{u} \cdot \vec{v} + k||\vec{v}||^2 = 0\)</p>
            <div id="sol_math_1_3" class="math-display"></div>
            <p id="sol_txt_1_3"></p>
        </div>
    </div>

    <h2>2. D√©finition Analytique</h2>
    <div class="exercice-bloc">
        <h3 class="niveau-titre">Niveau 3 : G√©om√©trie analytique</h3>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_A_2_3"></span>, <span id="enonce_B_2_3"></span>, <span id="enonce_C_2_3"></span>. On sait que \(\vec{BC} \perp \vec{AB}\).
        </div>
        <p><strong>Question :</strong> Trouver l'ordonn√©e \(y_C\).</p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_2_3', generateEx2_3)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_2_3')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_2_3">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_2_3"></div>
        </div>
    </div>

    <h2>3. Physique : Travail d'une Force</h2>
    <div class="exercice-bloc">
        <h3 class="niveau-titre">Niveau 3 : Analyse de donn√©es</h3>
        <div class="document-analyse">
            <p>Tableau des efforts de frottement :</p>
            <table class="data-table">
                <thead><tr><th>Portion</th><th>Distance \(d\) (m)</th><th>Effort \(\left\Vert \vec{F}_f \right\Vert\) (N)</th></tr></thead>
                <tbody>
                    <tr><td>A vers B (m√©tal)</td><td><span id="dAB_3"></span></td><td><span id="FfAB_3"></span></td></tr>
                    <tr><td>B vers C (bois)</td><td><span id="dBC_3"></span></td><td><span id="FfBC_3"></span></td></tr>
                </tbody>
            </table>
        </div>
        <p><strong>Question :</strong> Calculer le travail total \(W_{\text{frottement}}\) (A vers C).</p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_3_3', generateEx3_3)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_3_3')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_3_3">
            <p><strong>Solution :</strong></p>
            <div id="sol_math_3_3" class="math-display"></div>
            <p id="sol_txt_3_3"></p>
        </div>
    </div>
    
    <h2>4. Propri√©t√©s Alg√©briques</h2>
    <div class="exercice-bloc">
        <h3 class="niveau-titre">Niveau 2 : Carr√© scalaire</h3>
        <p><strong>Question :</strong> \(\left\Vert \vec{u} \right\Vert = \)<span id="u_norm_4"></span>, \(\left\Vert \vec{v} \right\Vert = \)<span id="v_norm_4"></span>, \(\vec{u} \cdot \vec{v} = \)<span id="u_dot_v_4"></span>. Calculer \(\left\Vert \vec{u} + \vec{v} \right\Vert\).</p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_4_2', generateEx4_2)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_4_2')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_4_2">
            <p><strong>Solution :</strong></p>
            <div id="sol_math_4_2" class="math-display"></div>
            <p id="sol_txt_4_2"></p>
        </div>
    </div>

    <h2>5. Application : Le Th√©or√®me d'Al-Kashi</h2>
    <div class="exercice-bloc">
        <h3 class="niveau-titre">Niveau 3 : Lecture de graphique et application</h3>
        <div class="document-analyse">
            <strong>Sch√©ma de l'√©querre OAB (g√©n√©r√© dynamiquement) :</strong>
            <p>Dimensions : \(OA = \)<span id="OA_5"></span> mm, \(OB = \)<span id="OB_5"></span> mm, \(\widehat{AOB} = \)<span id="AOB_5"></span>\(^\circ\).</p>
            <div class="canvas-container">
                <canvas id="canvas_ex5" width="400" height="300"></canvas>
            </div>
        </div>
        <p><strong>Question :</strong> D√©terminer la longueur \(AB\) (en mm) et l'angle \(\widehat{OAB}\) (en degr√©s).</p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_5_3', generateEx5_3)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_5_3')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_5_3">
            <p><strong>Solution :</strong></p>
            <ol>
                <li><strong>Longueur \(AB\) (Al-Kashi) :</strong>
                    <div id="sol_math_5_3_a" class="math-display"></div>
                </li>
                <li><strong>Angle \(\widehat{OAB}\) (R√©utilisation d'Al-Kashi) :</strong>
                    <div id="sol_math_5_3_b" class="math-display"></div>
                    <p id="sol_txt_5_3_b"></p>
                </li>
            </ol>
        </div>
    </div>
    
    <h2>6. Exercices de Synth√®se : Double Expression</h2>
    <div class="exercice-bloc">
        <h3 class="niveau-titre">Niveau 2 : D√©terminer un angle via les coordonn√©es</h3>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> Dans un rep√®re orthonorm√©, on donne les vecteurs <span id="enonce_u_6_1"></span> et <span id="enonce_v_6_1"></span>.
        </div>
        <p><strong>Question :</strong> D√©terminer \(\cos(\theta)\) puis \(\theta\).</p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_6_1', generateEx6_1)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_6_1')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_6_1">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_6_1"></div>
        </div>
    </div>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">Niveau 3 : Retrouver une coordonn√©e</h3>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_u_6_2"></span>, <span id="enonce_v_6_2"></span>.
            <div id="enonce_suite_6_2" style="margin-top:5px;"></div>
        </div>
        <p><strong>Question :</strong> D√©terminer \(y_v\).</p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_6_2', generateEx6_2)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_6_2')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_6_2">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_6_2"></div>
        </div>
    </div>
    <h2>7. Jongler avec les Formules (Synth√®se Avanc√©e)</h2>
    <p>Dans cette section, vous devez identifier l'inconnue et utiliser deux formules du produit scalaire pour la trouver.</p>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">7.1. Lien Analytique \(\leftrightarrow\) Polarisation</h3>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_7_1"></span>
        </div>
        <p><strong>Question :</strong> <span id="question_7_1"></span></p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_7_1', generateEx7_1)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_7_1')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_7_1">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_7_1"></div>
        </div>
    </div>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">7.2. Lien Analytique \(\leftrightarrow\) G√©om√©trique</h3>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_7_2"></span>
        </div>
        <p><strong>Question :</strong> <span id="question_7_2"></span></p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_7_2', generateEx7_2)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_7_2')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_7_2">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_7_2"></div>
        </div>
    </div>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">7.3. Lien Polarisation \(\leftrightarrow\) G√©om√©trique</h3>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_7_3"></span>
        </div>
        <p><strong>Question :</strong> <span id="question_7_3"></span></p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_7_3', generateEx7_3)">üîÑ Nouvelles valeurs</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_7_3')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_7_3">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_7_3"></div>
        </div>
    </div>
   <h2>8. Le D√©fi Ultime (M√©lange total)</h2>
    <p>Dans ces exercices, l'ordinateur choisit au hasard l'inconnue. √Ä vous de retrouver le chemin logique pour la calculer.</p>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">8.1. D√©fi Analytique & Normes</h3>
        <p><em>Variables possibles : \(\vec{u} \cdot \vec{v}, \left\Vert \vec{u} + \vec{v} \right\Vert, \left\Vert \vec{u} \right\Vert, \left\Vert \vec{v} \right\Vert, x, y, x', y'\)</em></p>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_8_1"></span>
        </div>
        <p><strong>Question :</strong> <span id="question_8_1"></span></p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_8_1', generateEx8_1)">üé≤ Nouveau Tirage</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_8_1')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_8_1">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_8_1"></div>
        </div>
    </div>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">8.2. D√©fi Coordonn√©es & Angles</h3>
        <p><em>Variables possibles : \(\vec{u} \cdot \vec{v}, x, y, x', y', \left\Vert \vec{u} \right\Vert, \left\Vert \vec{v} \right\Vert, \cos(\theta)\)</em></p>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_8_2"></span>
        </div>
        <p><strong>Question :</strong> <span id="question_8_2"></span></p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_8_2', generateEx8_2)">üé≤ Nouveau Tirage</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_8_2')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_8_2">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_8_2"></div>
        </div>
    </div>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">8.3. D√©fi G√©om√©trique Pur (Sans coord.)</h3>
        <p><em>Variables possibles : \(\vec{u} \cdot \vec{v}, \left\Vert \vec{u} + \vec{v} \right\Vert, \left\Vert \vec{u} \right\Vert, \left\Vert \vec{v} \right\Vert, \cos(\theta)\)</em></p>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_8_3"></span>
        </div>
        <p><strong>Question :</strong> <span id="question_8_3"></span></p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_8_3', generateEx8_3)">üé≤ Nouveau Tirage</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_8_3')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_8_3">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_8_3"></div>
        </div>
    </div>

    <div class="exercice-bloc">
        <h3 class="niveau-titre">8.4. Polarisation et Angle (Sans coordonn√©es)</h3>
        <p><em>Variables en jeu : \(\vec{u} \cdot \vec{v}, \left\Vert \vec{u} + \vec{v} \right\Vert, \left\Vert \vec{u} \right\Vert, \left\Vert \vec{v} \right\Vert, \cos(\theta)\)</em></p>
        <div class="document-analyse">
            <strong>Donn√©es :</strong> <span id="enonce_8_4"></span>
        </div>
        <p><strong>Question :</strong> <span id="question_8_4"></span></p>
        
        <button class="btn-action btn-reset-ex" onclick="resetExercise('sol_ex_8_4', generateEx8_4)">üîÑ Nouveau D√©fi</button>
        <button class="btn-action btn-solution" onclick="toggleSolution('sol_ex_8_4')">Afficher la Solution</button>
        
        <div class="solution-bloc" id="sol_ex_8_4">
            <p><strong>Solution :</strong></p>
            <div id="sol_content_8_4"></div>
        </div>
    </div>

    <div class="footer-actions">
        <button id="copyright-btn" class="btn-action">‚öñÔ∏è Droits d'Auteur</button>
    </div>

    <div id="copyrightModal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>‚öñÔ∏è Droits d'Auteur et Licence d'Utilisation</h2>
            <p><b>Auteur : Yann Merdy (yann.merdy@gmail.com)</b> - Novembre 2025</p>
            <hr>
            <h3>Licence d'Utilisation Non Commerciale</h3>
            <p>Ce code HTML/CSS/JavaScript ainsi que le contenu g√©n√©r√© par l'application ("Cours et Exercices Dynamiques : Le Produit Scalaire") sont la propri√©t√© intellectuelle exclusive de l'auteur, Yann Merdy.</p>
            
            <h4>Conditions :</h4>
            <ul>
                <li><b>Utilisation Priv√©e et √âducative (Autoris√©e) :</b> Vous √™tes autoris√©.e √† utiliser, copier, modifier et distribuer ce code et son contenu <b>uniquement</b> √† des fins <b>personnelles, √©ducatives et non lucratives</b>.</li>
                <li><b>Utilisation Commerciale (Interdite) :</b> Toute utilisation, distribution, int√©gration ou reproduction du code ou du contenu (total ou partiel) √† des fins <b>commerciales, lucratives ou professionnelles</b> est <b>strictement interdite</b> sans un accord √©crit pr√©alable et explicite de l'auteur.</li>
                <li><b>Attribution :</b> Toute reproduction ou modification doit conserver la mention de l'auteur originale (Yann Merdy) et la pr√©sente notice de droits d'auteur.</li>
            </ul>
            <p style="margin-top: 20px; font-style: italic;">Pour toute demande d'utilisation commerciale ou de licence sp√©cifique, veuillez contacter l'auteur √† l'adresse indiqu√©e ci-dessus.</p>
        </div>
    </div>

    <script>
        // --- UTILITAIRES ---
        // Fonction de formatage pour mettre les nombres n√©gatifs entre parenth√®ses
        function fmt(n) { return n < 0 ? "(" + n + ")" : n; }
        
        function getRandomInt(min, max) { 
            return Math.floor(Math.random() * (max - min + 1)) + min; 
        }

        // --- MOTEUR GRAPHIQUE ---
        
        function drawArrow(ctx, fromx, fromy, tox, toy, color = "#007bff", label = "") {
            const headlen = 10; 
            const angle = Math.atan2(toy - fromy, tox - fromx);
            
            ctx.beginPath();
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(tox, toy);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(tox, toy);
            ctx.fillStyle = color;
            ctx.fill();

            if(label) {
                ctx.fillStyle = color;
                ctx.font = "bold 14px Arial";
                ctx.fillText(label, tox + 5, toy - 5);
            }
        }

        function drawAngle(ctx, x, y, radius, startAngle, endAngle, label = "") {
            ctx.beginPath();
            ctx.arc(x, y, radius, startAngle, endAngle);
            ctx.strokeStyle = "#28a745";
            ctx.lineWidth = 1.5;
            ctx.stroke();
            if(label) {
                let midAngle = startAngle + (endAngle - startAngle)/2;
                ctx.fillStyle = "#28a745";
                ctx.font = "italic 14px Arial";
                ctx.fillText(label, x + (radius+15)*Math.cos(midAngle), y + (radius+15)*Math.sin(midAngle));
            }
        }

        function drawCourseGeo() {
            const canvas = document.getElementById('canvas_cours_geo');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,canvas.width, canvas.height);
            const Ox = 50, Oy = 150;
            drawArrow(ctx, Ox, Oy, Ox + 120, Oy, "#007bff", "u");
            const angleV = -40 * Math.PI / 180;
            drawArrow(ctx, Ox, Oy, Ox + 100*Math.cos(angleV), Oy + 100*Math.sin(angleV), "#dc3545", "v");
            drawAngle(ctx, Ox, Oy, 40, angleV, 0, "Œ∏");
            ctx.fillStyle = "black"; ctx.fillText("O", Ox-15, Oy+5);
        }
        
        // AJOUT : Fonction pour dessiner la projection orthogonale (Illustration)
        function drawCourseProjection() {
            const canvas = document.getElementById('canvas_cours_proj');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,canvas.width, canvas.height);
            
            const Ax = 50, Ay = 150;
            // Vecteur v horizontal pour simplifier l'illustration
            const Bx = 350, By = 150; 
            
            // Vecteur u
            const UendX = 250, UendY = 50;
            
            // Projection H (sur AB)
            const Hx = 250, Hy = 150;

            // Tracer v (AB)
            drawArrow(ctx, Ax, Ay, Bx, By, "#007bff", "v");
            
            // Tracer u (A -> Uend)
            drawArrow(ctx, Ax, Ay, UendX, UendY, "#dc3545", "u");

            // Tracer pointill√©s projection
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(UendX, UendY);
            ctx.lineTo(Hx, Hy);
            ctx.strokeStyle = "gray";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash

            // Tracer u' (AH) - Projection
            drawArrow(ctx, Ax, Ay, Hx, Hy, "#28a745", "");
            
            // Labels
            ctx.fillStyle = "black"; 
            ctx.fillText("A", Ax, Ay + 20);
            ctx.fillText("H", Hx, Hy + 20);
            ctx.fillStyle = "#28a745";
            ctx.fillText("u' (projet√©)", (Ax+Hx)/2 - 20, Hy + 20);
            
            // Angle droit
            ctx.beginPath();
            ctx.moveTo(Hx, Hy - 10);
            ctx.lineTo(Hx + 10, Hy - 10);
            ctx.lineTo(Hx + 10, Hy);
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawCourseWork() {
            const canvas = document.getElementById('canvas_cours_travail');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,canvas.width, canvas.height);
            ctx.beginPath(); ctx.moveTo(10, 150); ctx.lineTo(490, 150); ctx.strokeStyle = "#333"; ctx.lineWidth = 1; ctx.stroke();
            const bx = 50, by = 110, bw = 60, bh = 40;
            ctx.fillStyle = "#e9ecef"; ctx.fillRect(bx, by, bw, bh); ctx.strokeRect(bx, by, bw, bh);
            ctx.fillStyle = "#333"; ctx.fillText("m", bx+25, by+25);
            drawArrow(ctx, bx+bw, by+bh, bx+bw+150, by+bh, "#28a745", "AB (d√©placement)");
            const cx = bx + bw/2; const cy = by + bh/2; const fLen = 80; const angleF = -30 * Math.PI / 180;
            drawArrow(ctx, cx, cy, cx + fLen*Math.cos(angleF), cy + fLen*Math.sin(angleF), "#d63384", "F");
            ctx.setLineDash([5, 3]); ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + 60, cy); ctx.stroke(); ctx.setLineDash([]);
            drawAngle(ctx, cx, cy, 30, angleF, 0, "Œ∏");
        }

        function drawCourseAlKashi() {
            const canvas = document.getElementById('canvas_cours_alkashi');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,canvas.width, canvas.height);
            const Ax = 50, Ay = 200; const Bx = 300, By = 200; const Cx = 200, Cy = 50;
            ctx.beginPath(); ctx.moveTo(Ax, Ay); ctx.lineTo(Bx, By); ctx.lineTo(Cx, Cy); ctx.closePath();
            ctx.strokeStyle = "#333"; ctx.lineWidth = 2; ctx.stroke();
            ctx.fillStyle = "black"; ctx.font = "bold 14px Arial"; ctx.fillText("A", Ax-15, Ay+5); ctx.fillText("B", Bx+5, By+5); ctx.fillText("C", Cx-5, Cy-10);
            ctx.fillStyle = "#007bff"; ctx.fillText("c (AB)", (Ax+Bx)/2, Ay+20); ctx.fillText("b (AC)", (Ax+Cx)/2 - 20, (Ay+Cy)/2); ctx.fillText("a (BC)", (Bx+Cx)/2 + 10, (By+Cy)/2);
            const angCA = Math.atan2(Ay-Cy, Ax-Cx); const angCB = Math.atan2(By-Cy, Bx-Cx);
            drawAngle(ctx, Cx, Cy, 30, angCB, angCA, "C");
        }

        function drawEx5(OA, OB, degAngle) {
            const canvas = document.getElementById('canvas_ex5');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,canvas.width, canvas.height);
            const angleRad = -degAngle * Math.PI / 180; const scale = 1.5;
            const Ox = 50; const Oy = 250;
            const Ax = Ox + OA * scale; const Ay = Oy;
            const Bx = Ox + OB * scale * Math.cos(angleRad); const By = Oy + OB * scale * Math.sin(angleRad);
            ctx.beginPath(); ctx.moveTo(Ox, Oy); ctx.lineTo(Ax, Ay); ctx.lineTo(Bx, By); ctx.lineTo(Ox, Oy);
            ctx.strokeStyle = "#333"; ctx.lineWidth = 2; ctx.stroke();
            ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(Ox, Oy, 3, 0, 2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(Ax, Ay, 3, 0, 2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(Bx, By, 3, 0, 2*Math.PI); ctx.fill();
            ctx.fillStyle = "black"; ctx.font = "bold 14px Arial"; ctx.fillText("O", Ox-15, Oy+5); ctx.fillText("A", Ax+5, Ay+5); ctx.fillText("B", Bx, By-10);
            ctx.fillStyle = "#007bff"; ctx.fillText(OA + " mm", (Ox+Ax)/2 - 10, Oy+20); ctx.fillText(OB + " mm", (Ox+Bx)/2 - 30, (Oy+By)/2);
            drawAngle(ctx, Ox, Oy, 30, angleRad, 0, degAngle + "¬∞");
        }

        // --- LOGIQUE METIER ---

        function resetExercise(solutionId, generatorFunction) {
            document.getElementById(solutionId).style.display = 'none';
            generatorFunction();
            MathJax.typeset();
        }

        // Ex 1.2
        // Ex 1.2 : D√©finition G√©om√©trique
        function generateEx1_2() {
            let u = getRandomInt(2, 8); 
            let v = getRandomInt(2, 8);
            document.getElementById('u_norm_1_2').innerText = u; 
            document.getElementById('v_norm_1_2').innerText = v;
            
            // Biblioth√®que d'angles remarquables de base (0 √† pi)
            let bases = [
                { num: 1, den: 6, cosStr: "\\frac{\\sqrt{3}}{2}", val: Math.sqrt(3)/2 },
                { num: 1, den: 4, cosStr: "\\frac{\\sqrt{2}}{2}", val: Math.sqrt(2)/2 },
                { num: 1, den: 3, cosStr: "\\frac{1}{2}", val: 0.5 },
                { num: 1, den: 2, cosStr: "0", val: 0 },
                { num: 2, den: 3, cosStr: "-\\frac{1}{2}", val: -0.5 },
                { num: 3, den: 4, cosStr: "-\\frac{\\sqrt{2}}{2}", val: -Math.sqrt(2)/2 },
                { num: 5, den: 6, cosStr: "-\\frac{\\sqrt{3}}{2}", val: -Math.sqrt(3)/2 },
                { num: 1, den: 1, cosStr: "-1", val: -1 } // Pi
            ];

            let base = bases[getRandomInt(0, bases.length - 1)];
            
            // G√©n√©ration d'un angle complexe (Mesure non principale)
            // On ajoute k tours (2k*pi) ou on change le signe
            let k = getRandomInt(1, 4) * (Math.random() < 0.5 ? 1 : -1); // Nombre de tours relatifs
            let isNegative = Math.random() < 0.5;
            
            // Calcul du num√©rateur affich√© : (num/den) + 2k
            // Convertissons tout en fraction sur 'den'
            // Angle = base + 2k*pi = (num + 2k*den)/den * pi
            let rawNum = base.num + (2 * k * base.den);
            if (isNegative) { rawNum = -rawNum; }

            // Construction de l'affichage LaTeX de l'angle donn√©
            let angleInputTex = "";
            if (base.den === 1) { // Cas multiples de pi
                angleInputTex = `${rawNum}\\pi`;
            } else {
                angleInputTex = `\\dfrac{${rawNum}\\pi}{${base.den}}`;
            }

            // Calcul pour la solution (Mesure Principale)
            // La mesure principale doit √™tre dans ]-pi, pi]
            // Pour le cosinus, cos(-x) = cos(x), donc le signe initial importe peu pour le r√©sultat final,
            // mais il est crucial pour la m√©thode de la mesure principale.
            
            let principalNum = base.num;
            let principalDen = base.den;
            let finalCos = base.cosStr;
            // Si l'angle g√©n√©r√© √©tait n√©gatif, cos est pair donc cos(-x)=cos(x)
            // Mais pour l'explication de la mesure principale :
            let methodStep = "";
            
            // Logique d'explication "Mesure Principale"
            let totalTours = Math.abs(k);
            let signSymbol = rawNum < 0 ? "-" : "";
            
            // Explication didactique
            let explicationHTML = "";
            explicationHTML += `<p><strong>1. Recherche de la mesure principale :</strong><br>`;
            explicationHTML += `L'angle donn√© est \\(\\alpha = ${angleInputTex}\\). On cherche l'angle \\(\\theta \\in ]-\\pi; \\pi]\\) tel que \\(\\alpha = \\theta + 2k\\pi\\).<br>`;
            
            // M√©thode simplifi√©e : division euclidienne du num√©rateur par 2*den
            let twoDen = 2 * base.den;
            let remainder = rawNum % twoDen;
            
            // Ajustement pour tomber dans ]-den*pi, den*pi]
            // Si le reste est trop grand (> den), on retire un tour (2*den)
            if (remainder > base.den) remainder -= twoDen;
            if (remainder <= -base.den) remainder += twoDen;

            let principalTex = (base.den === 1) ? `${remainder}\\pi` : `\\dfrac{${remainder}\\pi}{${base.den}}`;
            
            explicationHTML += `On retire les tours complets (multiples de \\(2\\pi\\)).<br>`;
            explicationHTML += `Ici, \\(\\dfrac{${rawNum}\\pi}{${base.den}} = ${principalTex} + ${rawNum < 0 ? "-" : ""}${Math.abs(k)}\\times(2\\pi)\\).<br>`;
            explicationHTML += `La mesure principale est donc <strong>\\(\\theta = ${principalTex}\\)</strong>.</p>`;

            explicationHTML += `<p><strong>2. Valeur du cosinus :</strong><br>`;
            
            // Gestion Cosinus Pair / Impair / Remarquable
            // Si le reste est n√©gatif, on utilise la parit√© cos(-x) = cos(x)
            if (remainder < 0) {
                 explicationHTML += `Comme la fonction cosinus est paire, \\(\\cos(${principalTex}) = \\cos(${(base.den===1 ? Math.abs(remainder)+"\\pi" : "\\dfrac{"+Math.abs(remainder)+"\\pi}{"+base.den+"}")})\\).<br>`;
            }
            explicationHTML += `D'apr√®s le cercle trigonom√©trique : \\[\\cos\\left(${principalTex}\\right) = ${base.cosStr}\\]</p>`;

            // Calcul final produit scalaire
            let prod = u * v; 
            let resTex = "";
            
            // Formatage propre du r√©sultat final (eviter 10 * 0.5 = 5.0000)
            if (Math.abs(base.val) === 0.5) { resTex = (prod * base.val).toString(); } 
            else if (base.val === 0) { resTex = "0"; } 
            else if (Math.abs(base.val) === 1) { resTex = (prod * base.val).toString(); }
            else {
                // Cas avec racine
                let rootPart = base.cosStr.replace("-", "").replace("\\dfrac{", "").replace("}{2}", "").replace("\\frac{", "");
                let coeff = prod / 2;
                let signStr = (base.val < 0) ? "-" : "";
                if (Number.isInteger(coeff)) {
                    resTex = `${signStr}${coeff}${rootPart}`;
                } else {
                    resTex = `${signStr}\\dfrac{${prod}}{2}${rootPart}`;
                }
            }

            let finalCalc = `<p><strong>3. Calcul du produit scalaire :</strong><br>
            \\[\\vec{u} \\cdot \\vec{v} = ${u} \\times ${v} \\times \\left( ${base.cosStr} \\right) = ${prod} \\times \\left( ${base.cosStr} \\right) = ${resTex}\\]</p>`;

            document.getElementById('angle_val_1_2').innerHTML = `\\(${angleInputTex}\\)`;
            document.getElementById('angle_analysis_1_2').innerHTML = ""; // On vide le vieux placeholder
            document.getElementById('sol_cos_1_2').style.display = 'none'; // On cache les vieux blocs
            document.getElementById('sol_calc_1_2').innerHTML = explicationHTML + finalCalc;
        }

        // Ex 1.3 : Orthogonalit√©
        function generateEx1_3() {
            let k; do { k = getRandomInt(-5, 5); } while (k === 0);
            let v = getRandomInt(3, 8); let u = Math.abs(k) * v + getRandomInt(2, 10);
            document.getElementById('u_norm_1').innerText = u; document.getElementById('v_norm_1').innerText = v;
            let sign = (k < 0) ? "-" : "+"; let abs_k = Math.abs(k);
            document.getElementById('vec_w_eq').innerHTML = "\\(\\vec{w} = \\vec{u} " + sign + " " + abs_k + "\\vec{v}\\)";
            
            let num = -k * v * v; let den = u * v; let cos_theta = num / den; let angle = Math.acos(cos_theta) * (180 / Math.PI);
            let minus_k = -k;

            // SOLUTION DIDACTIQUE
            let html = `<p><strong>1. Comprendre la condition d'orthogonalit√© :</strong><br>
            Dire que \\(\\vec{w}\\) est orthogonal √† \\(\\vec{v}\\) signifie que leur produit scalaire est nul :
            \\[\\vec{w} \\cdot \\vec{v} = 0\\]</p>
            
            <p><strong>2. Remplacer \\(\\vec{w}\\) par son expression :</strong><br>
            On remplace \\(\\vec{w}\\) par \\((\\vec{u} ${sign} ${abs_k}\\vec{v})\\) :
            \\[(\\vec{u} ${sign} ${abs_k}\\vec{v}) \\cdot \\vec{v} = 0\\]</p>

            <p><strong>3. D√©velopper (Distributivit√©) :</strong><br>
            On distribue le produit scalaire :
            \\[\\vec{u} \\cdot \\vec{v} ${sign} ${abs_k} (\\vec{v} \\cdot \\vec{v}) = 0\\]
            Or, \\(\\vec{v} \\cdot \\vec{v} = \\left\\Vert \\vec{v} \\right\\Vert^2\\). L'√©quation devient :
            \\[\\vec{u} \\cdot \\vec{v} ${sign} ${abs_k} \\left\\Vert \\vec{v} \\right\\Vert^2 = 0\\]</p>

            <p><strong>4. Isoler \\(\\vec{u} \\cdot \\vec{v}\\) et utiliser la formule du cosinus :</strong><br>
            \\[\\vec{u} \\cdot \\vec{v} = ${-k}\\left\\Vert \\vec{v} \\right\\Vert^2\\]
            On sait aussi que \\(\\vec{u} \\cdot \\vec{v} = \\left\\Vert \\vec{u} \\right\\Vert \\times \\left\\Vert \\vec{v} \\right\\Vert \\times \\cos(\\theta)\\).
            Donc :
            \\[\\left\\Vert \\vec{u} \\right\\Vert \\times \\left\\Vert \\vec{v} \\right\\Vert \\times \\cos(\\theta) = ${-k} \\times \\left\\Vert \\vec{v} \\right\\Vert^2\\]</p>

            <p><strong>5. Calculer \\(\\cos(\\theta)\\) :</strong><br>
            On simplifie par \\(\\left\\Vert \\vec{v} \\right\\Vert\\) et on isole le cosinus :
            \\[\\cos(\\theta) = \\frac{${minus_k} \\times \\left\\Vert \\vec{v} \\right\\Vert}{\\left\\Vert \\vec{u} \\right\\Vert} = \\frac{${minus_k} \\times ${v}}{${u}} = \\frac{${minus_k*v}}{${u}} \\approx ${cos_theta.toFixed(3)}\\]</p>
            
            <p><strong>Conclusion :</strong> \\(\\theta = \\cos^{-1}(${cos_theta.toFixed(3)}) \\approx ${angle.toFixed(1)}^\\circ\\).</p>`;

            document.getElementById('sol_math_1_3').innerHTML = html;
            document.getElementById('sol_txt_1_3').innerText = ""; // Nettoyage
        }

        // Ex 2.3 : Analytique
        function generateEx2_3() {
            let Ax=getRandomInt(-5,5), Ay=getRandomInt(-5,5), Bx=getRandomInt(-5,5), By=getRandomInt(-5,5), Cx=getRandomInt(-5,5);
            if(Bx===Ax && By===Ay) Bx+=2; let ux=Bx-Ax, uy=By-Ay; if(uy===0){uy=1;By+=1;}
            let Cy = By - (Cx - Bx) * ux / uy;
            let unorm = Math.sqrt(ux*ux + uy*uy), BCx = Cx-Bx;
            
            document.getElementById('enonce_A_2_3').innerHTML = "\\(A(" + Ax + "; " + Ay + ")\\)";
            document.getElementById('enonce_B_2_3').innerHTML = "\\(B(" + Bx + "; " + By + ")\\)";
            document.getElementById('enonce_C_2_3').innerHTML = "\\(C(" + Cx + "; y_C)\\)";

            // SOLUTION DIDACTIQUE
            let html = `<p><strong>1. Calcul des coordonn√©es des vecteurs :</strong><br>
            Formule : \\(\\vec{AB} \\begin{pmatrix} x_B - x_A \\\\ y_B - y_A \\end{pmatrix}\\) et \\(\\vec{BC} \\begin{pmatrix} x_C - x_B \\\\ y_C - y_B \\end{pmatrix}\\)<br>
            \\(\\vec{AB} \\begin{pmatrix} ${Bx} - (${fmt(Ax)}) \\\\ ${By} - (${fmt(Ay)}) \\end{pmatrix} = \\begin{pmatrix} ${ux} \\\\ ${uy} \\end{pmatrix}\\)<br>
            \\(\\vec{BC} \\begin{pmatrix} ${Cx} - (${fmt(Bx)}) \\\\ y_C - (${fmt(By)}) \\end{pmatrix} = \\begin{pmatrix} ${BCx} \\\\ y_C - (${fmt(By)}) \\end{pmatrix}\\)</p>
            
            <p><strong>2. Condition d'orthogonalit√© (Analytique) :</strong><br>
            Deux vecteurs sont orthogonaux si leur produit scalaire analytique \\(xx' + yy'\\) est nul.<br>
            Ici : \\(x_{\\vec{AB}} \\times x_{\\vec{BC}} + y_{\\vec{AB}} \\times y_{\\vec{BC}} = 0\\)</p>

            <p><strong>3. Mise en √©quation :</strong><br>
            On remplace par les valeurs calcul√©es :<br>
            \\(${fmt(ux)} \\times ${fmt(BCx)} + ${fmt(uy)} \\times (y_C - (${fmt(By)})) = 0\\)<br>
            \\(${ux*BCx} + ${uy}(y_C - (${fmt(By)})) = 0\\)</p>

            <p><strong>4. R√©solution :</strong><br>
            \\(${uy}(y_C - (${fmt(By)})) = -(${ux*BCx})\\)<br>
            \\(y_C - (${fmt(By)}) = \\frac{${-ux*BCx}}{${uy}}\\)<br>
            \\(y_C = \\frac{${-ux*BCx}}{${uy}} + (${fmt(By)}) = ${Cy.toFixed(2)}\\)</p>`;
            
            document.getElementById('sol_content_2_3').innerHTML = html;
        }

        // Ex 3.3 : Travail force
        function generateEx3_3() {
            let dAB=getRandomInt(5,20), dBC=getRandomInt(5,20), FfAB=getRandomInt(10,50), FfBC=getRandomInt(10,50);
            document.getElementById('dAB_3').innerText=dAB; document.getElementById('FfAB_3').innerText=FfAB;
            document.getElementById('dBC_3').innerText=dBC; document.getElementById('FfBC_3').innerText=FfBC;
            let WAB = FfAB*dAB*(-1), WBC=FfBC*dBC*(-1), Wtot=WAB+WBC;
            
            // SOLUTION DIDACTIQUE
            let html = `<p><strong>1. Rappel de la formule du travail :</strong><br>
            \\[W = \\vec{F} \\cdot \\vec{d} = \\left\\Vert \\vec{F} \\right\\Vert \\times d \\times \\cos(\\alpha)\\]
            Ici, la force de frottement est toujours <strong>oppos√©e</strong> au mouvement. L'angle est donc \\(\\alpha = 180^\\circ\\) et \\(\\cos(180^\\circ) = -1\\).<br>
            La formule se simplifie en : \\(W = - F \\times d\\).</p>

            <p><strong>2. Calcul sur le trajet AB (M√©tal) :</strong><br>
            \\(W_{AB} = - ${FfAB} \\times ${dAB} = ${fmt(WAB)} \\text{ Joules}\\).</p>

            <p><strong>3. Calcul sur le trajet BC (Bois) :</strong><br>
            \\(W_{BC} = - ${FfBC} \\times ${dBC} = ${fmt(WBC)} \\text{ Joules}\\).</p>

            <p><strong>4. Travail Total :</strong><br>
            On additionne les travaux des deux parties :<br>
            \\(W_{total} = W_{AB} + W_{BC} = ${fmt(WAB)} + (${fmt(WBC)}) = ${Wtot} \\text{ Joules}\\).</p>`;

            document.getElementById('sol_math_3_3').innerHTML = html;
            document.getElementById('sol_txt_3_3').innerText = "";
        }

        // Ex 4.2 : Carr√© Scalaire
        function generateEx4_2() {
            let u=getRandomInt(4,10), v=getRandomInt(4,10), dot=getRandomInt(-u*v+1, u*v);
            document.getElementById('u_norm_4').innerText=u; document.getElementById('v_norm_4').innerText=v; document.getElementById('u_dot_v_4').innerText=dot;
            let nsq = u*u + v*v + 2*dot;

            // SOLUTION DIDACTIQUE
            let html = `<p><strong>1. Identifier l'identit√© remarquable vectorielle :</strong><br>
            On cherche \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert\\). On utilise la formule du carr√© de la somme :
            \\[\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = \\left\\Vert \\vec{u} \\right\\Vert^2 + \\left\\Vert \\vec{v} \\right\\Vert^2 + 2(\\vec{u} \\cdot \\vec{v})\\]</p>

            <p><strong>2. Application num√©rique :</strong><br>
            On remplace par les donn√©es (\\(\\left\\Vert \\vec{u} \\right\\Vert=${u}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert=${v}\\), \\(\\vec{u} \\cdot \\vec{v}=${dot}\\)) :<br>
            \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = ${u}^2 + ${v}^2 + 2 \\times (${fmt(dot)})\\)<br>
            \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = ${u*u} + ${v*v} + (${2*dot}) = ${nsq}\\)</p>

            <p><strong>3. Conclusion :</strong><br>
            Pour trouver la norme, on prend la racine carr√©e :<br>
            \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert = \\sqrt{${nsq}} \\approx ${Math.sqrt(nsq).toFixed(2)}\\)</p>`;

            document.getElementById('sol_math_4_2').innerHTML = html;
            document.getElementById('sol_txt_4_2').innerText = "";
        }

        // Ex 5.3 : Al-Kashi
        function generateEx5_3() {
            let OA=getRandomInt(80,150), OB=getRandomInt(70,120), AOB=getRandomInt(30,150);
            document.getElementById('OA_5').innerText=OA; document.getElementById('OB_5').innerText=OB; document.getElementById('AOB_5').innerText=AOB;
            drawEx5(OA, OB, AOB);
            let rad=AOB*Math.PI/180, ABsq=(OA*OA+OB*OB-2*OA*OB*Math.cos(rad)).toFixed(2), AB=Math.sqrt(ABsq).toFixed(2);
            let cosOAB=((OA*OA+parseFloat(ABsq)-OB*OB)/(2*OA*AB)).toFixed(3), angOAB=(Math.acos(cosOAB)*180/Math.PI).toFixed(1);

            // SOLUTION DIDACTIQUE
            let htmlA = `<p><strong>1. Calcul de AB (Th√©or√®me d'Al-Kashi) :</strong><br>
            Dans le triangle OAB, la formule reliant les trois c√¥t√©s et l'angle \\(\\widehat{AOB}\\) est :
            \\[AB^2 = OA^2 + OB^2 - 2 \\times OA \\times OB \\times \\cos(\\widehat{AOB})\\]
            Application num√©rique :
            \\[AB^2 = ${OA}^2 + ${OB}^2 - 2 \\times ${OA} \\times ${OB} \\times \\cos(${AOB}^\\circ)\\]
            Calcul : \\(AB^2 \\approx ${ABsq}\\).<br>
            Donc \\(AB = \\sqrt{${ABsq}} \\approx ${AB} \\text{ mm}\\).</p>`;

            let htmlB = `<p><strong>2. Calcul de l'angle \\(\\widehat{OAB}\\) :</strong><br>
            On r√©utilise Al-Kashi, mais centr√© sur l'angle A :
            \\[OB^2 = OA^2 + AB^2 - 2 \\times OA \\times AB \\times \\cos(\\widehat{OAB})\\]
            On isole le cosinus :
            \\[\\cos(\\widehat{OAB}) = \\frac{OA^2 + AB^2 - OB^2}{2 \\times OA \\times AB}\\]
            Application num√©rique :
            \\[\\cos(\\widehat{OAB}) \\approx \\frac{${OA}^2 + ${AB}^2 - ${OB}^2}{2 \\times ${OA} \\times ${AB}} \\approx ${cosOAB}\\]
            Donc \\(\\widehat{OAB} = \\cos^{-1}(${cosOAB}) \\approx ${angOAB}^\\circ\\).</p>`;

            document.getElementById('sol_math_5_3_a').innerHTML = htmlA;
            document.getElementById('sol_math_5_3_b').innerHTML = htmlB;
            document.getElementById('sol_txt_5_3_b').innerText = "";
        }

        // Ex 6.1
        // Ex 6.1 : Coordonn√©es -> Angle
        function generateEx6_1() {
            let ux, uy, vx, vy;
            // On s'assure d'avoir des vecteurs non nuls
            do { ux = getRandomInt(-4, 4); uy = getRandomInt(-4, 4); } while(ux===0 && uy===0);
            do { vx = getRandomInt(-4, 4); vy = getRandomInt(-4, 4); } while(vx===0 && vy===0);
            
            let texU = "\\(\\vec{u} \\begin{pmatrix} " + ux + " \\\\\\\\ " + uy + " \\end{pmatrix}\\)";
            let texV = "\\(\\vec{v} \\begin{pmatrix} " + vx + " \\\\\\\\ " + vy + " \\end{pmatrix}\\)";
            document.getElementById('enonce_u_6_1').innerHTML = texU;
            document.getElementById('enonce_v_6_1').innerHTML = texV;

            let dotAnalytic = ux * vx + uy * vy;
            let normU = Math.sqrt(ux*ux + uy*uy);
            let normV = Math.sqrt(vx*vx + vy*vy);
            let cosTheta = dotAnalytic / (normU * normV);
            
            // Tentative de d√©tection d'angle remarquable pour l'affichage
            // Tol√©rance pour les erreurs d'arrondi flottant
            let epsilon = 0.00001;
            let remarkableAngle = null;
            let valAbs = Math.abs(cosTheta);
            
            if (Math.abs(valAbs - 0.5) < epsilon) remarkableAngle = "\\pi/3";
            else if (Math.abs(valAbs - Math.sqrt(2)/2) < epsilon) remarkableAngle = "\\pi/4";
            else if (Math.abs(valAbs - Math.sqrt(3)/2) < epsilon) remarkableAngle = "\\pi/6";
            else if (valAbs < epsilon) remarkableAngle = "\\pi/2";
            else if (Math.abs(valAbs - 1) < epsilon) remarkableAngle = "0";

            let thetaRad = Math.acos(Math.max(-1, Math.min(1, cosTheta)));
            let thetaDisplay = "";
            
            if (remarkableAngle) {
                // Construction de la fraction LaTeX
                if (cosTheta < -epsilon && remarkableAngle !== "0" && remarkableAngle !== "\\pi/2") {
                     // Cas obtus (ex: pi - pi/3 = 2pi/3)
                     // Simple mapping pour les cas standards
                     if(remarkableAngle === "\\pi/3") thetaDisplay = "\\dfrac{2\\pi}{3}";
                     if(remarkableAngle === "\\pi/4") thetaDisplay = "\\dfrac{3\\pi}{4}";
                     if(remarkableAngle === "\\pi/6") thetaDisplay = "\\dfrac{5\\pi}{6}";
                } else if (cosTheta < -epsilon && remarkableAngle === "0") {
                    thetaDisplay = "\\pi";
                } else {
                    thetaDisplay = remarkableAngle.replace("/", "}{").replace("\\pi", "\\dfrac{\\pi");
                    if (thetaDisplay.includes("dfrac")) thetaDisplay += "}"; // fermeture accolade
                    else thetaDisplay = remarkableAngle === "0" ? "0" : "\\dfrac{\\pi}{2}";
                }
            } else {
                thetaDisplay = thetaRad.toFixed(3) + " \\text{ rad}";
            }

            let html = `<p><strong>Objectif :</strong> On cherche la mesure de l'angle g√©om√©trique \\(\\theta\\) dans l'intervalle \\([0; \\pi]\\).</p>
            
            <p><strong>1. Calcul du cosinus :</strong><br>
            \\[\\cos(\\theta) = \\frac{\\vec{u} \\cdot \\vec{v}}{\\left\\Vert \\vec{u} \\right\\Vert \\times \\left\\Vert \\vec{v} \\right\\Vert} = \\frac{${dotAnalytic}}{\\sqrt{${(normU*normU).toFixed(0)}} \\times \\sqrt{${(normV*normV).toFixed(0)}}}\\]
            \\[\\cos(\\theta) \\approx ${cosTheta.toFixed(4)}\\]</p>

            <p><strong>2. D√©duction de la mesure principale :</strong><br>
            L'angle entre deux vecteurs est d√©fini dans l'intervalle \\([0; \\pi]\\) (de 0¬∞ √† 180¬∞).<br>
            C'est <strong>la mesure principale</strong> positive de l'angle orient√©.<br>`;
            
            if (remarkableAngle) {
                html += `On reconna√Æt ici une valeur remarquable (\\(${cosTheta < 0 ? "-" : ""}${remarkableAngle}\\)).<br>
                La solution unique dans \\([0; \\pi]\\) est :
                \\[\\theta = ${thetaDisplay}\\]`;
            } else {
                html += `Ce n'est pas une valeur remarquable. On utilise la calculatrice (touche \\(\\arccos\\) ou \\(\\cos^{-1}\\)) qui donne toujours le r√©sultat dans cet intervalle exact :
                \\[\\theta \\approx ${thetaDisplay}\\]`;
            }
            html += `</p>`;
            
            document.getElementById('sol_content_6_1').innerHTML = html;
        }

        // Ex 6.2 : Mixte
        function generateEx6_2() {
            let ux, uy, vx, vy;
            do { ux = getRandomInt(-4, 4); uy = getRandomInt(-4, 4); } while(ux===0 && uy===0);
            do { vx = getRandomInt(-4, 4); vy = getRandomInt(-4, 4); } while((vx===0 && vy===0) || uy===0); 
            
            let texU = "\\(\\vec{u} \\begin{pmatrix} " + ux + " \\\\\\\\ " + uy + " \\end{pmatrix}\\)";
            let texV = "\\(\\vec{v} \\begin{pmatrix} " + vx + " \\\\\\\\ y_v \\end{pmatrix}\\)";
            document.getElementById('enonce_u_6_2').innerHTML = texU;
            document.getElementById('enonce_v_6_2').innerHTML = texV;

            let dot = ux*vx + uy*vy; 
            let nu = Math.sqrt(ux*ux + uy*uy);
            let nv = Math.sqrt(vx*vx + vy*vy);
            let cosT = dot / (nu * nv); 
            
            let texSuite = "On donne \\(\\left\\Vert \\vec{v} \\right\\Vert = \\sqrt{" + (vx*vx+vy*vy) + "}\\) et \\(\\cos(\\theta) \\approx " + fmt(parseFloat(cosT.toFixed(3))) + "\\).";
            document.getElementById('enonce_suite_6_2').innerHTML = texSuite;
            
            // SOLUTION DIDACTIQUE
            let html = `<p><strong>Strat√©gie :</strong> On va calculer le produit scalaire de deux mani√®res diff√©rentes et √©galer les r√©sultats.</p>
            
            <p><strong>1. Mani√®re G√©om√©trique (avec les donn√©es de l'√©nonc√©) :</strong><br>
            Formule : \\(\\vec{u} \\cdot \\vec{v} = \\left\\Vert \\vec{u} \\right\\Vert \\times \\left\\Vert \\vec{v} \\right\\Vert \\times \\cos(\\theta)\\)<br>
            Il faut d'abord calculer \\(\\left\\Vert \\vec{u} \\right\\Vert = \\sqrt{${ux}^2 + ${uy}^2} = \\sqrt{${ux*ux+uy*uy}} \\approx ${nu.toFixed(2)}\\).<br>
            Calcul : \\(${nu.toFixed(2)} \\times \\sqrt{${vx*vx+vy*vy}} \\times ${fmt(parseFloat(cosT.toFixed(3)))} \\approx ${dot}\\).<br>
            <em>(On retient que le produit scalaire vaut ${dot}).</em></p>

            <p><strong>2. Mani√®re Analytique (avec l'inconnue) :</strong><br>
            Formule : \\(\\vec{u} \\cdot \\vec{v} = xx' + yy'\\)<br>
            Calcul : \\(${fmt(ux)} \\times ${fmt(vx)} + ${fmt(uy)} \\times y_v = ${ux*vx} + ${fmt(uy)}y_v\\).</p>

            <p><strong>3. R√©solution de l'√©quation :</strong><br>
            On √©gale les deux r√©sultats :<br>
            \\(${ux*vx} + ${fmt(uy)}y_v = ${dot}\\)<br>
            \\(${fmt(uy)}y_v = ${dot} - (${ux*vx})\\)<br>
            \\(${fmt(uy)}y_v = ${dot - ux*vx}\\)<br>
            \\(y_v = \\frac{${dot - ux*vx}}{${uy}} = ${vy}\\).</p>`;
            
            document.getElementById('sol_content_6_2').innerHTML = html;
        }
        // --- CORRECTIF D√âFINITIF SECTION 7 ---

        function generateEx7_1() {
            let ux = getRandomInt(-4, 4), uy = getRandomInt(-4, 4);
            let vx = getRandomInt(-4, 4), vy = getRandomInt(-4, 4);
            if(ux===0 && uy===0) ux=2; if(vx===0 && vy===0) vx=2;

            let dot = ux*vx + uy*vy;
            let nU2 = ux*ux + uy*uy;
            let nV2 = vx*vx + vy*vy;
            let nSum2 = nU2 + nV2 + 2*dot;
            let nSum = Math.sqrt(nSum2);

            let mode = Math.random() < 0.5 ? 'findSum' : 'findDot';
            let htmlEnonce, htmlQuestion, htmlSol;

            if (mode === 'findSum') {
                htmlEnonce = `Soit \\(\\vec{u}\\begin{pmatrix} ${ux} \\\\ ${uy} \\end{pmatrix}\\) et \\(\\vec{v}\\begin{pmatrix} ${vx} \\\\ ${vy} \\end{pmatrix}\\).`;
                // CORRECTION ICI : \\right au lieu de \right
                htmlQuestion = "D√©terminer \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert\\) en passant par le produit scalaire (sans calculer les coordonn√©es de la somme).";
                
                htmlSol = `<ol>
                    <li>Calcul du produit scalaire (Analytique) : <br>
                    \\(\\vec{u} \\cdot \\vec{v} = ${fmt(ux)} \\times ${fmt(vx)} + ${fmt(uy)} \\times ${fmt(vy)} = ${dot}\\).</li>
                    <li>Calcul des carr√©s des normes : <br>
                    \\(\\left\\Vert \\vec{u} \\right\\Vert^2 = ${ux}^2 + ${uy}^2 = ${nU2}\\) et \\(\\left\\Vert \\vec{v} \\right\\Vert^2 = ${vx}^2 + ${vy}^2 = ${nV2}\\).</li>
                    <li>Utilisation de la formule de polarisation invers√©e : <br>
                    \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = 2(\\vec{u} \\cdot \\vec{v}) + \\left\\Vert \\vec{u} \\right\\Vert^2 + \\left\\Vert \\vec{v} \\right\\Vert^2\\) <br>
                    \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = 2(${fmt(dot)}) + ${nU2} + ${nV2} = ${nSum2}\\).</li>
                    <li>Conclusion : \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert = \\sqrt{${nSum2}} \\approx ${nSum.toFixed(2)}\\).</li>
                </ol>`;
            } else {
                htmlEnonce = `On donne \\(\\left\\Vert \\vec{u} \\right\\Vert^2 = ${nU2}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert^2 = ${nV2}\\) et \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = ${nSum2}\\).`;
                htmlQuestion = "D√©terminer le produit scalaire \\(\\vec{u} \\cdot \\vec{v}\\).";
                
                htmlSol = `<p>On utilise l'identit√© de polarisation :</p>
                <div class="math-display">\\[\\vec{u} \\cdot \\vec{v} = \\dfrac{1}{2} \\left( \\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 - \\left\\Vert \\vec{u} \\right\\Vert^2 - \\left\\Vert \\vec{v} \\right\\Vert^2 \\right)\\]</div>
                <p>Calcul : \\(\\dfrac{1}{2} (${nSum2} - ${nU2} - ${nV2}) = \\dfrac{1}{2} (${2*dot}) = ${dot}\\).</p>`;
            }

            document.getElementById('enonce_7_1').innerHTML = htmlEnonce;
            document.getElementById('question_7_1').innerHTML = htmlQuestion;
            document.getElementById('sol_content_7_1').innerHTML = htmlSol;
        }

        function generateEx7_2() {
            let ux = getRandomInt(1, 5), uy = getRandomInt(1, 5);
            let vx = getRandomInt(1, 5), vy = getRandomInt(-5, 5); 
            
            let dot = ux*vx + uy*vy;
            let nU = Math.sqrt(ux*ux + uy*uy);
            let nV = Math.sqrt(vx*vx + vy*vy);
            let cosTheta = dot / (nU * nV);
            let theta = Math.acos(Math.max(-1, Math.min(1, cosTheta))) * (180 / Math.PI);

            let htmlEnonce = `\\(\\vec{u}\\begin{pmatrix} ${ux} \\\\ ${uy} \\end{pmatrix}\\) et \\(\\vec{v}\\begin{pmatrix} ${vx} \\\\ ${vy} \\end{pmatrix}\\) dans un rep√®re orthonorm√©.`;
            let htmlQuestion = "D√©terminer la mesure de l'angle \\(\\theta = (\\vec{u}, \\vec{v})\\) au degr√© pr√®s.";
            
            // CORRECTION ICI : \\right au lieu de \right dans le htmlSol
            let htmlSol = `<ol>
                <li><strong>√âtape 1 (Analytique) :</strong> Calcul du produit scalaire avec les coordonn√©es.<br>
                \\(\\vec{u} \\cdot \\vec{v} = ${ux}\\times${vx} + ${uy}\\times${vy} = ${dot}\\).</li>
                <li><strong>√âtape 2 :</strong> Calcul des normes.<br>
                \\(\\left\\Vert \\vec{u} \\right\\Vert = \\sqrt{${ux}^2+${uy}^2} \\approx ${nU.toFixed(2)}\\) et \\(\\left\\Vert \\vec{v} \\right\\Vert = \\sqrt{${vx}^2+${vy}^2} \\approx ${nV.toFixed(2)}\\).</li>
                <li><strong>√âtape 3 (G√©om√©trique) :</strong> On isole le cosinus.<br>
                \\(\\cos(\\theta) = \\dfrac{\\vec{u} \\cdot \\vec{v}}{\\left\\Vert \\vec{u} \\right\\Vert \\times \\left\\Vert \\vec{v} \\right\\Vert} = \\dfrac{${dot}}{${nU.toFixed(2)} \\times ${nV.toFixed(2)}} \\approx ${cosTheta.toFixed(3)}\\).</li>
                <li><strong>R√©sultat :</strong> \\(\\theta = \\cos^{-1}(${cosTheta.toFixed(3)}) \\approx ${theta.toFixed(0)}^\\circ\\).</li>
            </ol>`;

            document.getElementById('enonce_7_2').innerHTML = htmlEnonce;
            document.getElementById('question_7_2').innerHTML = htmlQuestion;
            document.getElementById('sol_content_7_2').innerHTML = htmlSol;
        }

        function generateEx7_3() {
            let nU = getRandomInt(3, 8);
            let nV = getRandomInt(3, 8);
            
            // Liste des angles remarquables (Degr√©s et Radians)
            let commonAngles = [
                { deg: 30, rad: "\\dfrac{\\pi}{6}" },
                { deg: 45, rad: "\\dfrac{\\pi}{4}" },
                { deg: 60, rad: "\\dfrac{\\pi}{3}" },
                { deg: 90, rad: "\\dfrac{\\pi}{2}" },
                { deg: 120, rad: "\\dfrac{2\\pi}{3}" },
                { deg: 135, rad: "\\dfrac{3\\pi}{4}" },
                { deg: 150, rad: "\\dfrac{5\\pi}{6}" }
            ];
            
            let angleObj = commonAngles[getRandomInt(0, commonAngles.length - 1)];
            let useRad = Math.random() < 0.5; // 50% de chance d'√™tre en radians
            
            let thetaDisplay = useRad ? angleObj.rad : angleObj.deg + "^\\circ";
            let thetaRadVal = angleObj.deg * Math.PI / 180;
            
            let cosVal = Math.cos(thetaRadVal);
            let dot = nU * nV * cosVal;
            
            let nSum2 = nU*nU + nV*nV + 2*dot;
            let nSum = Math.sqrt(nSum2);

            let mode = Math.random() < 0.5 ? 'findSum' : 'findAngle';
            let htmlEnonce, htmlQuestion, htmlSol;

            if (mode === 'findSum') {
                htmlEnonce = `\\(\\left\\Vert \\vec{u} \\right\\Vert = ${nU}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert = ${nV}\\) et \\(\\theta = ${thetaDisplay}\\).`;
                htmlQuestion = "D√©terminer \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert\\).";
                
                // Adaptation de la solution pour mentionner la conversion si n√©cessaire
                let rappelAngle = useRad ? `(soit ${angleObj.deg}^\\circ)` : "";
                
                htmlSol = `<ol>
                    <li>Calcul du produit scalaire (G√©om√©trique) :<br>
                    \\(\\vec{u} \\cdot \\vec{v} = ${nU} \\times ${nV} \\times \\cos(${thetaDisplay}) \\approx ${dot.toFixed(2)}\\).</li>
                    <li>Utilisation de la polarisation (isolant la somme) :<br>
                    \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = 2(\\vec{u} \\cdot \\vec{v}) + \\left\\Vert \\vec{u} \\right\\Vert^2 + \\left\\Vert \\vec{v} \\right\\Vert^2\\)<br>
                    \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = 2(${dot.toFixed(2)}) + ${nU*nU} + ${nV*nV} \\approx ${nSum2.toFixed(2)}\\).</li>
                    <li>R√©sultat : \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert \\approx \\sqrt{${nSum2.toFixed(2)}} \\approx ${nSum.toFixed(2)}\\).</li>
                </ol>`;
            } else {
                htmlEnonce = `\\(\\left\\Vert \\vec{u} \\right\\Vert = ${nU}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert = ${nV}\\) et \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert \\approx ${nSum.toFixed(2)}\\).`;
                htmlQuestion = "Retrouver l'angle \\(\\theta\\) (en " + (useRad ? "radians" : "degr√©s") + ").";
                
                htmlSol = `<ol>
                    <li>Calcul du produit scalaire via Polarisation (3 normes connues) :<br>
                    \\(\\vec{u} \\cdot \\vec{v} = \\frac{1}{2} (${nSum.toFixed(2)}^2 - ${nU}^2 - ${nV}^2) \\approx ${dot.toFixed(2)}\\).</li>
                    <li>Lien avec la formule G√©om√©trique :<br>
                    \\(\\vec{u} \\cdot \\vec{v} = \\left\\Vert \\vec{u} \\right\\Vert \\times \\left\\Vert \\vec{v} \\right\\Vert \\times \\cos(\\theta)\\).</li>
                    <li>Isolation de l'angle :<br>
                    \\(\\cos(\\theta) = \\frac{${dot.toFixed(2)}}{${nU} \\times ${nV}} \\approx ${cosVal.toFixed(3)}\\).<br>
                    Donc \\(\\theta \\approx ${thetaDisplay}\\).</li>
                </ol>`;
            }

            document.getElementById('enonce_7_3').innerHTML = htmlEnonce;
            document.getElementById('question_7_3').innerHTML = htmlQuestion;
            document.getElementById('sol_content_7_3').innerHTML = htmlSol;
        }
        // --- SECTION 8 : LE D√âFI ULTIME (CORRIG√â) ---

        // --- CORRECTIF D√âFINITIF SECTION 8.1 ---

        function generateEx8_1() {
            // 1. G√©n√©rer le sc√©nario complet
            let ux = getRandomInt(-5, 5), uy = getRandomInt(-5, 5);
            let vx = getRandomInt(-5, 5), vy = getRandomInt(-5, 5);
            if(ux===0 && uy===0) ux=1; if(vx===0 && vy===0) vx=1;

            let dot = ux*vx + uy*vy;
            let nU2 = ux*ux + uy*uy;
            let nV2 = vx*vx + vy*vy;
            let nSum2 = nU2 + nV2 + 2*dot;
            let nSum = Math.sqrt(nSum2);

            let type = getRandomInt(0, 2); 
            let htmlE, htmlQ, htmlS;

            if (type === 0) {
                if (vx === 0) vx = 1; 
                dot = ux*vx + uy*vy; 
                htmlE = `On donne \\(\\vec{u}\\begin{pmatrix} x \\\\ ${uy} \\end{pmatrix}\\), \\(\\vec{v}\\begin{pmatrix} ${vx} \\\\ ${vy} \\end{pmatrix}\\) et \\(\\vec{u} \\cdot \\vec{v} = ${dot}\\).`;
                htmlQ = "D√©terminer la valeur de \\(x\\).";
                htmlS = `<ol><li>On √©crit la formule analytique : \\(x \\times x' + y \\times y' = \\vec{u} \\cdot \\vec{v}\\).</li><li>On remplace : \\(x \\times ${fmt(vx)} + ${fmt(uy)} \\times ${fmt(vy)} = ${dot}\\).</li><li>√âquation : \\(${vx}x + (${uy*vy}) = ${dot}\\).</li><li>R√©solution : \\(${vx}x = ${dot} - (${uy*vy}) = ${dot - uy*vy}\\), donc \\(x = ${ux}\\).</li></ol>`;
            } else if (type === 1) {
                htmlE = `On donne \\(\\vec{u}\\begin{pmatrix} ${ux} \\\\ ${uy} \\end{pmatrix}\\) et \\(\\vec{v}\\begin{pmatrix} ${vx} \\\\ ${vy} \\end{pmatrix}\\).`;
                // CORRECTION ICI : \\right au lieu de \right
                htmlQ = "Calculer \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert\\).";
                htmlS = `<ol><li><strong>M√©thode 1 (Directe) :</strong> Calculer les coordonn√©es de la somme.<br>\\(\\vec{u}+\\vec{v} \\begin{pmatrix} ${ux}+${fmt(vx)} \\\\ ${uy}+${fmt(vy)} \end{pmatrix} = \\begin{pmatrix} ${ux+vx} \\\\ ${uy+vy} \end{pmatrix}\\).<br>Norme : \\(\\sqrt{(${ux+vx})^2 + (${uy+vy})^2} = \\sqrt{${nSum2}} \\approx ${nSum.toFixed(2)}\\).</li><li><strong>M√©thode 2 (Polarisation) :</strong> Calculer le produit scalaire et les normes individuelles.<br>\\(\\vec{u} \\cdot \\vec{v} = ${dot}\\), \\(\\left\\Vert \\vec{u} \\right\\Vert^2 = ${nU2}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert^2 = ${nV2}\\).<br>\\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = ${nU2} + ${nV2} + 2(${dot}) = ${nSum2}\\).</li></ol>`;
            } else {
                // CORRECTION MAJEURE ICI : Il y avait un \right qui causait le bug dans htmlE
                htmlE = `On ne connait pas les coordonn√©es, mais on sait que \\(\\left\\Vert \\vec{u} \\right\\Vert^2 = ${nU2}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert^2 = ${nV2}\\) et \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = ${nSum2}\\).`;
                htmlQ = "Retrouver la valeur de \\(\\vec{u} \\cdot \\vec{v}\\).";
                htmlS = `<p>Il faut utiliser l'identit√© de polarisation :</p><div class="math-display">\\[\\vec{u} \\cdot \\vec{v} = \\frac{1}{2} \\left( \\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 - \\left\\Vert \\vec{u} \\right\\Vert^2 - \\left\\Vert \\vec{v} \\right\\Vert^2 \\right)\\]</div><p>Calcul : \\(\\frac{1}{2} (${nSum2} - ${nU2} - ${nV2}) = \\frac{1}{2} (${2*dot}) = ${dot}\\).</p>`;
            }

            document.getElementById('enonce_8_1').innerHTML = htmlE;
            document.getElementById('question_8_1').innerHTML = htmlQ;
            document.getElementById('sol_content_8_1').innerHTML = htmlS;
        }

        function generateEx8_2() {
            let ux=getRandomInt(2,5), uy=getRandomInt(1,4);
            let vx=getRandomInt(1,4), vy=getRandomInt(-4,4);
            let dot = ux*vx + uy*vy;
            let nU = Math.sqrt(ux*ux+uy*uy); let nV = Math.sqrt(vx*vx+vy*vy);
            let cosV = dot/(nU*nV); 
            let angDeg = Math.acos(Math.max(-1,Math.min(1,cosV)))*180/Math.PI;

            let type = getRandomInt(0, 2);
            let htmlE, htmlQ, htmlS;

            if (type === 0) { 
                htmlE = `\\(\\vec{u}\\begin{pmatrix} ${ux} \\\\ ${uy} \\end{pmatrix}\\) et \\(\\vec{v}\\begin{pmatrix} ${vx} \\\\ ${vy} \\end{pmatrix}\\).`;
                htmlQ = "Calculer \\(\\cos(\\theta)\\).";
                htmlS = `<p><strong>Raisonnement :</strong> On utilise la d√©finition g√©om√©trique invers√©e.</p>
                <p><strong>1. Produit Scalaire (Analytique) :</strong> \\(\\vec{u} \\cdot \\vec{v} = ${dot}\\).</p>
                <p><strong>2. Normes :</strong> \\(\\approx ${nU.toFixed(2)}\\) et \\(\\approx ${nV.toFixed(2)}\\).</p>
                <p><strong>3. Quotient :</strong> \\(\\cos(\\theta) = \\frac{Num√©rateur}{D√©nominateur} = \\frac{${dot}}{${nU.toFixed(2)}\\times${nV.toFixed(2)}} \\approx ${cosV.toFixed(3)}\\).</p>`;
            } else if (type === 1) { 
                // CAS PARTICULIER : Angle donn√© -> on choisit un "joli" angle pour supporter les radians
                let commonAngles = [
                    { deg: 30, rad: "\\dfrac{\\pi}{6}" }, { deg: 45, rad: "\\dfrac{\\pi}{4}" }, { deg: 60, rad: "\\dfrac{\\pi}{3}" },
                    { deg: 90, rad: "\\dfrac{\\pi}{2}" }, { deg: 120, rad: "\\dfrac{2\\pi}{3}" }, { deg: 135, rad: "\\dfrac{3\\pi}{4}" }
                ];
                let angleObj = commonAngles[getRandomInt(0, commonAngles.length - 1)];
                let useRad = Math.random() < 0.5;
                let thetaDisplay = useRad ? angleObj.rad : angleObj.deg + "^\\circ";
                
                // Recalcul du produit scalaire th√©orique bas√© sur cet angle parfait
                let dotTheoretical = nU * nV * Math.cos(angleObj.deg * Math.PI / 180);

                htmlE = `\\(\\left\\Vert \\vec{u} \\right\\Vert=${nU.toFixed(2)}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert=${nV.toFixed(2)}\\) et \\(\\theta=${thetaDisplay}\\).`;
                htmlQ = "Calculer \\(\\vec{u} \\cdot \\vec{v}\\).";
                htmlS = `<p><strong>Raisonnement :</strong> C'est l'application directe de la d√©finition g√©om√©trique.</p>
                <p><strong>Formule :</strong> \\(\\vec{u} \\cdot \\vec{v} = \\left\\Vert \\vec{u} \\right\\Vert \\times \\left\\Vert \\vec{v} \\right\\Vert \\times \\cos(\\theta)\\)</p>
                <p><strong>Calcul :</strong> \\(${nU.toFixed(2)} \\times ${nV.toFixed(2)} \\times \\cos(${thetaDisplay}) \\approx ${dotTheoretical.toFixed(2)}\\).</p>`;
            } else { 
                htmlE = `\\(\\vec{u}\\begin{pmatrix} ${ux} \\\\ ${uy} \\end{pmatrix}\\), \\(\\vec{v}\\begin{pmatrix} ${vx} \\\\ y' \\end{pmatrix}\\) et \\(\\vec{u} \\cdot \\vec{v} = ${dot}\\).`;
                htmlQ = "Retrouver \\(y'\\).";
                htmlS = `<p><strong>Raisonnement :</strong> On pose l'√©quation analytique du produit scalaire.</p>
                <p><strong>√âquation :</strong> \\(x x' + y y' = Dot\\) <br>
                \\(${ux}\\times${vx} + ${uy}y' = ${dot}\\)</p>
                <p><strong>R√©solution :</strong> \\(${uy}y' = ${dot} - ${ux*vx} \\implies y' = ${vy}\\).</p>`;
            }
            document.getElementById('enonce_8_2').innerHTML = htmlE;
            document.getElementById('question_8_2').innerHTML = htmlQ;
            document.getElementById('sol_content_8_2').innerHTML = htmlS;
        }

        function generateEx8_3() {
            let nU = getRandomInt(3,8), nV = getRandomInt(3,8);
            
            // Logique Radians / Degr√©s
            let commonAngles = [
                { deg: 45, rad: "\\dfrac{\\pi}{4}" },
                { deg: 60, rad: "\\dfrac{\\pi}{3}" },
                { deg: 90, rad: "\\dfrac{\\pi}{2}" },
                { deg: 120, rad: "\\dfrac{2\\pi}{3}" },
                { deg: 135, rad: "\\dfrac{3\\pi}{4}" }
            ];
            let angleObj = commonAngles[getRandomInt(0, commonAngles.length - 1)];
            let useRad = Math.random() < 0.5;
            let thetaDisplay = useRad ? angleObj.rad : angleObj.deg + "^\\circ";
            
            let cosVal = Math.cos(angleObj.deg*Math.PI/180);
            let dot = nU*nV*cosVal;
            let nSum2 = nU*nU + nV*nV + 2*dot;
            
            let type = getRandomInt(0,1); 
            if (type===0) { 
                document.getElementById('enonce_8_3').innerHTML = `\\(\\left\\Vert \\vec{u} \\right\\Vert=${nU}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert=${nV}\\) et \\(\\theta=${thetaDisplay}\\).`;
                document.getElementById('question_8_3').innerHTML = "Calculer \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert\\).";
                document.getElementById('sol_content_8_3').innerHTML = `<p><strong>Raisonnement :</strong> On utilise la formule du carr√© scalaire (Al-Kashi vectoriel).</p>
                <p><strong>1. Calcul du terme crois√© (produit scalaire) :</strong><br>
                \\(\\vec{u} \\cdot \\vec{v} = ${nU} \\times ${nV} \\times \\cos(${thetaDisplay}) \\approx ${dot.toFixed(2)}\\)</p>
                <p><strong>2. Formule de la somme au carr√© :</strong><br>
                \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2 = \\left\\Vert \\vec{u} \\right\\Vert^2 + \\left\\Vert \\vec{v} \\right\\Vert^2 + 2(\\vec{u} \\cdot \\vec{v})\\)<br>
                \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert^2= ${nU}^2 + ${nV}^2 + 2(${dot.toFixed(2)}) \\approx ${nSum2.toFixed(2)}\\)</p>
                <p><strong>3. Racine carr√©e :</strong> \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert\\approx ${Math.sqrt(nSum2).toFixed(2)}\\).</p>`;
            } else { 
                document.getElementById('enonce_8_3').innerHTML = `\\(\\left\\Vert \\vec{u} \\right\\Vert=${nU}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert=${nV}\\) et \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert \\approx ${Math.sqrt(nSum2).toFixed(2)}\\).`;
                document.getElementById('question_8_3').innerHTML = "Retrouver l'angle \\(\\theta\\) (en " + (useRad ? "radians" : "degr√©s") + ").";
                document.getElementById('sol_content_8_3').innerHTML = `<p><strong>Raisonnement :</strong> On a les 3 normes, on commence par la Polarisation pour trouver le produit scalaire, puis on d√©duit l'angle.</p>
                <p><strong>1. Polarisation :</strong> \\(\\vec{u} \\cdot \\vec{v} = \\frac{1}{2}(${nSum2.toFixed(1)} - ${nU}^2 - ${nV}^2) \\approx ${dot.toFixed(1)}\\).</p>
                <p><strong>2. Cosinus :</strong> \\(\\frac{\\vec{u} \\cdot \\vec{v}}{\\left\\Vert \\vec{u} \\right\\Vert \\left\\Vert \\vec{v} \\right\\Vert} = \\frac{${dot.toFixed(1)}}{${nU}\\times${nV}} \\approx ${cosVal.toFixed(3)}\\).</p>
                <p><strong>3. Angle :</strong> \\(\\cos^{-1}(${cosVal.toFixed(3)}) \\approx ${thetaDisplay}\\).</p>`;
            }
        }
	function generateEx8_4() {
            let nU = getRandomInt(3,8), nV = getRandomInt(3,8);
            
            // Logique Radians / Degr√©s
            let commonAngles = [
                { deg: 45, rad: "\\dfrac{\\pi}{4}" },
                { deg: 60, rad: "\\dfrac{\\pi}{3}" },
                { deg: 90, rad: "\\dfrac{\\pi}{2}" },
                { deg: 120, rad: "\\dfrac{2\\pi}{3}" },
                { deg: 135, rad: "\\dfrac{3\\pi}{4}" }
            ];
            let angleObj = commonAngles[getRandomInt(0, commonAngles.length - 1)];
            let useRad = Math.random() < 0.5;
            let thetaDisplay = useRad ? angleObj.rad : angleObj.deg + "^\\circ";

            let cosVal = Math.cos(angleObj.deg*Math.PI/180);
            let dot = nU*nV*cosVal;
            let nSum2 = nU*nU + nV*nV + 2*dot;
            
            document.getElementById('enonce_8_4').innerHTML = `\\(\\left\\Vert \\vec{u} \\right\\Vert=${nU}\\), \\(\\left\\Vert \\vec{v} \\right\\Vert=${nV}\\) et \\(\\left\\Vert \\vec{u} + \\vec{v} \\right\\Vert \\approx ${Math.sqrt(nSum2).toFixed(2)}\\).`;
            document.getElementById('question_8_4').innerHTML = "Retrouver l'angle \\(\\theta\\) (en " + (useRad ? "radians" : "degr√©s") + ").";
            
            document.getElementById('sol_content_8_4').innerHTML = `<p><strong>Raisonnement :</strong> On a les 3 normes, on commence par la Polarisation pour trouver le produit scalaire, puis on d√©duit l'angle.</p>
            <p><strong>1. Polarisation :</strong> \\(\\vec{u} \\cdot \\vec{v} = \\frac{1}{2}(${nSum2.toFixed(1)} - ${nU}^2 - ${nV}^2) \\approx ${dot.toFixed(1)}\\).</p>
            <p><strong>2. Cosinus :</strong> \\(\\frac{\\vec{u} \\cdot \\vec{v}}{\\left\\Vert \\vec{u} \\right\\Vert \\left\\Vert \\vec{v} \\right\\Vert} = \\frac{${dot.toFixed(1)}}{${nU}\\times${nV}} \\approx ${cosVal.toFixed(3)}\\).</p>
            <p><strong>3. Angle :</strong> \\(\\cos^{-1}(${cosVal.toFixed(3)}) \\approx ${thetaDisplay}\\).</p>`;
        }
        function toggleSolution(solutionId) {
            const div = document.getElementById(solutionId);
            div.style.display = (div.style.display === 'none' || div.style.display === '') ? 'block' : 'none';
        }

        // --- GESTION MODALE DROITS D'AUTEUR ---
        document.addEventListener('DOMContentLoaded', () => {
            const copyrightBtn = document.getElementById('copyright-btn');
            const copyrightModal = document.getElementById('copyrightModal');
            const closeBtn = document.querySelector('.close-btn');

            function openModal() {
                copyrightModal.style.display = "block";
            }
            function closeModal() {
                copyrightModal.style.display = "none";
            }

            if(copyrightBtn) copyrightBtn.addEventListener('click', openModal);
            if(closeBtn) closeBtn.addEventListener('click', closeModal);
            window.addEventListener('click', (event) => {
                if (event.target === copyrightModal) {
                    closeModal();
                }
            });
        });

        function generateAllExercises() {
            document.querySelectorAll('.solution-bloc').forEach(b => b.style.display = 'none');
            // Dessins statiques
            drawCourseGeo();
            drawCourseProjection(); // AJOUT : Dessin de la projection
            drawCourseWork();
            drawCourseAlKashi();
            // Exos
            generateEx1_2(); generateEx1_3(); generateEx2_3(); 
            generateEx3_3(); generateEx4_2(); generateEx5_3();
            generateEx6_1(); generateEx6_2();
	    generateEx7_1(); generateEx7_2(); generateEx7_3();
            // NOUVEAU
            generateEx8_1(); generateEx8_2(); generateEx8_3();generateEx8_4();
            MathJax.typeset();
        }

        window.onload = generateAllExercises;
    </script>
</body>
</html>
